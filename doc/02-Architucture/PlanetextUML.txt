@startuml
'──────────────────────────────────────────────────────────────
'  0) CONFIG & UTILS
'──────────────────────────────────────────────────────────────
package "Config & Utils" {
    class Settings {
        + get(key:str, default:Any=None) : Any
        - _CACHE : Dict[str,Any]
    }

    class Paths {
        + PATHS : TypedDict
        + ROOT  : Path
    }

    class SimpleLogger {
        + log(msg:str)   : None
        + error(msg:str) : None
        - _logger : logging.Logger
    }
}

'──────────────────────────────────────────────────────────────
'  1) INGESTION / MEMORY
'──────────────────────────────────────────────────────────────
package "Ingestion / Memory" {

    class DocumentLoader {
        + load_documents(subfolder:str) : List[Tuple[str,str]]
        - root : Path
    }

    class Chunker {
        + split(file_path:str, text:str, chunk_size:int=500, overlap:int=100) : List[Tuple[str,str]]
    }

    class Embedder {
        + embed(texts:List[str]) : List[List[float]]
        - model : str
        - client : OpenAI
    }

    interface IVectorStore {
        + add(ids:List[str], vectors:List[List[float]], meta:List[Dict]) : None
        + query(vector:List[float], k:int=10) : List[str]
        + snapshot(timestamp:str) : None
    }

    class VectorStoreNP implements IVectorStore {
        + add(ids,vectors,meta) : None
        + query(vector,k=10) : List[str]
        + snapshot(ts:str) : None
        - persist_path : Path
        - db_file : Path
        - _ids : List[str]
        - _meta : List[Dict]
        - _emb : ndarray
        - _id2idx : Dict[str,int]
    }

    ' --- ConversationMemory (read-only; two-layer; Layer-E = selection-only semantic index)
    class ConversationMemory {
        + get_recent(k:int=5) : List[Tuple[str,str]]      ' Layer-G (recency window)
        + get_episodic() : List[Tuple[str,str]]           ' Layer-E (episodic, on-topic)
        - k_default : int
        - soft_fading : bool
        - conflict_policy : str    ' ❖ FILES > newer > older (dedup)
        - capacity_cap : int       ' hard cap for selection-only vectors (E)
    }

    ' FileManifest is Must (hash + mtime) for deterministic inclusion/versioning
    class FileManifest {
        + path : str
        + sha  : str              ' sha256 or MD5
        + mtime: float
        + type : str
    }

    DocumentLoader --> Chunker : raw text
    Chunker --> Embedder : chunks
    Embedder --> IVectorStore : ids + vectors
    Paths ..> DocumentLoader : uses PATHS.raw_docs
    Paths ..> VectorStoreNP  : uses PATHS.vector_pkls
}

'──────────────────────────────────────────────────────────────
'  2) RETRIEVAL & RANKING
'──────────────────────────────────────────────────────────────
package "Retrieval & Ranking" {

    class DocScore {
        + id : str
        + score : float
    }

    class Reranker {
        + rerank(ids:List[str], query:str) : List[str]
    }

    class Retriever {
        + retrieve(query:str, k:int=10) : List[DocScore]
        - _vs : IVectorStore
        - _emb : Embedder
        - _reranker : Reranker
    }

    Retriever --> IVectorStore
    Retriever --> Embedder
    Retriever --> Reranker
    Retriever ..> DocScore
}

'──────────────────────────────────────────────────────────────
'  3) AGENTS (A1–A4)
'──────────────────────────────────────────────────────────────
package "Agents (app/agents)" {

    class A1_DCI {
        + build_files_block(named_files:List[str], lock:bool) : str
        - pack_threshold_tokens : int
        - file_manifest : Optional[Any]
    }

    class A2_PromptShaper {
        + propose(question:str) : Dict[str,str]           ' {intent, domain, headers}
        + audit_and_rerun(shape:Dict, s_ctx:List[str]) : bool  ' single bounded re-run gate
    }

    class A3_NLIGate {
        + filter(candidates:List[str], question:str) : List[str]
        - theta : float
    }

    class A4_Condenser {
        + condense(kept:List[str]) : List[str]   ' S_ctx lines: Facts/Constraints/Open Issues
    }
}

'──────────────────────────────────────────────────────────────
'  5) PROMPT ORCHESTRATION
'──────────────────────────────────────────────────────────────
package "Prompt Orchestration" {

    class PromptBuilder {
        + build(question:str, files_block:str, s_ctx:List[str], shape:Dict=None) : str
        - template : str
    }

    class LLMClient {
        + complete(prompt:str) : str
        + estimate_cost(tokens:int) : float
        - model : str
    }
}

'──────────────────────────────────────────────────────────────
'  6) APPLICATION LAYER (Controller & UI)
'──────────────────────────────────────────────────────────────
package "Application Layer" {

    class AppController {
        + handle(user_prompt:str, named_files:List[str], exact_lock:bool) : str
        - shaper : A2_PromptShaper
        - dci : A1_DCI
        - gate : A3_NLIGate
        - condenser : A4_Condenser
        - retriever : Retriever
        - reranker : Reranker
        - prompt_builder : PromptBuilder
        - llm : LLMClient
        - eligibility_pool : Set[str]
        - exact_lock : bool
        - convmem : ConversationMemory
    }

    class StreamlitUI {
        + render() : None
        + send_to_history(text:str) : None   ' UI-09 (append external reply)
        - ctrl : AppController
    }

    StreamlitUI --> AppController : user actions
}

'──────────────────────────────────────────────────────────────
'  7) CROSS-PACKAGE DEPENDENCIES & FLOW
'──────────────────────────────────────────────────────────────
' Controller Orchestration
AppController --> A2_PromptShaper : propose()
AppController --> A1_DCI          : build_files_block()
AppController --> Retriever       : retrieve() [if not exact_lock]
AppController --> Reranker        : rerank()
AppController --> A3_NLIGate      : filter()
AppController --> A4_Condenser    : condense() -> S_ctx
AppController --> A2_PromptShaper : audit_and_rerun()  ' bounded re-run (scope change)
AppController --> PromptBuilder   : build()
AppController --> LLMClient       : complete()

' History exposure (read-only)
AppController ..> ConversationMemory : reads G/E (non-authoritative)
PromptBuilder ..> ConversationMemory : may show RECENT HISTORY

' External Reply path (UI-08/09)
StreamlitUI ..> ConversationMemory : append external reply (source=external)

' Ingestion path
DocumentLoader --> Chunker
Chunker --> Embedder
Embedder --> IVectorStore

' PromptBuilder inputs
PromptBuilder ..> A1_DCI        : receives ❖ FILES
PromptBuilder ..> A4_Condenser  : receives S_ctx

' Misc
Settings ..> LLMClient : API keys/config
Settings ..> Embedder  : API keys/config
SimpleLogger ..> AppController : ephemeral logs/status

note right of AppController
  Authority order in PromptBuilder:
  [Hard Rules] → [Project Memory] → [❖ FILES]
  → [S_ctx] → [Task/Mode]
  (RECENT HISTORY is optional & non-authoritative)
  Personal use only: no Tooling, no MVP, no persistent logs.
end note

note bottom of VectorStoreNP
  Current default:
  NumPy-backed exact cosine
  with .pkl snapshots.
end note
A1_DCI -[hidden]down-> A2_PromptShaper
A2_PromptShaper -[hidden]down-> A3_NLIGate
A3_NLIGate -[hidden]down-> A4_Condenser
@enduml
