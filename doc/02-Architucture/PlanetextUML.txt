@startuml RAGstream2_Full
'──────────────────────────────────────────────────────────────
'  GLOBAL SETTINGS
'──────────────────────────────────────────────────────────────
left to right direction
skinparam linetype ortho
skinparam classAttributeIconSize 0
skinparam packageStyle rectangle
hide empty members

'──────────────────────────────────────────────────────────────
'  0) CONFIG & UTILS
'──────────────────────────────────────────────────────────────
package "Config & Utils" {
    class Settings {
        + get(key:str, default:Any=None) : Any
        - _CACHE : Dict[str,Any]
    }

    class Paths {
        + PATHS : TypedDict
        + ROOT  : Path
    }

    class SimpleLogger {
        + log(msg:str)   : None
        + error(msg:str) : None
        - _logger : logging.Logger
    }

    ' Feature-2: Debug Logger (developer-oriented; optional)
    class DebugLogger {
        + logWriteText(msg:str, level:str="INFO") : None
        + logWriteVar(pairs:Any) : None
        + rotate_if_needed() : None
        - vars_enabled : bool
        - min_level : str
        - session_id : str
        - trace_path : Path
        - vars_path  : Path
    }
}

'──────────────────────────────────────────────────────────────
'  1) INGESTION & MEMORY LAYER
'──────────────────────────────────────────────────────────────
package "Ingestion / Memory" {

    class DocumentLoader {
        + load_documents(subfolder:str) : List[Tuple[str,str]]
        - root : Path
    }

    class Chunker {
        + split(file_path:str, text:str, chunk_size:int=500, overlap:int=100) : List[Tuple[str,str]]
    }

    class Embedder {
        + embed(texts:List[str]) : List[List[float]]
        - model : str
        - client : OpenAI
    }

    '── New: manifest/ledger for skip logic
    class FileManifest {
        + compute_sha256(file_path:str) : str
        + load_manifest(manifest_path:str) : Dict
        + diff(records_now:List[Record], manifest_prev:Dict) : Tuple[List[Record],List[Record],List[Record]]
        + publish_atomic(manifest_dict:Dict, manifest_path:str) : None
    }

    note right of FileManifest
      Record schema (per file):
      {
        "path": str,     ' relative to doc_root
        "sha256": str,   ' content hash
        "mtime": float,  ' UNIX mtime
        "size": int      ' bytes
      }
    end note

    '── New: central orchestrator for documents ingestion
    class IngestionManager {
        + run(subfolder:str, store:ChromaVectorStoreBase, chunker:Chunker, embedder:Embedder, manifest_path:str, chunk_size:int=500, overlap:int=100, delete_old_versions:bool=True, delete_tombstones:bool=False) : IngestionStats
        - doc_root : Path
        - loader   : DocumentLoader
    }

    class IngestionStats {
        + files_scanned        : int
        + to_process           : int
        + unchanged            : int
        + tombstones           : int
        + chunks_added         : int
        + vectors_upserted     : int
        + deleted_old_versions : int
        + deleted_tombstones   : int
        + published_manifest_path : str
        + embedded_bytes       : int
    }

    '── Replaced NP stores with Chroma-backed stores
    class ChromaVectorStoreBase {
        + add(ids:List[str], vectors:List[List[float]], metadatas:List[Dict]=None) : None
        + query(vector:List[float], k:int=10, where:Dict=None) : List[str]
        + delete_where(where:Dict) : None
        + snapshot(timestamp:str=None) : Path
        + collection() : Any
        - persist_path : Path
        - collection_name : str
        - _client : chromadb.PersistentClient
        - _col : chromadb.Collection
        - _pre_add(...) : tuple
        - _post_add(...) : None
        - _pre_query(...) : tuple
        - _post_query(ids:List[str], raw_result:Dict) : List[str]
    }

    class VectorStoreChroma extends ChromaVectorStoreBase {
        + make_chunk_id(rel_path:str, sha256:str, chunk_idx:int) : str
        + name() : str
        + persist_root() : Path
        + count() : int
    }

    class HistoryStoreChroma extends ChromaVectorStoreBase

    '── Conversation memory (postponed in implementation; kept as spec)
    class ConversationMemory {
        + get_recent(k:int=5) : List[Tuple[str,str]]       ' Layer-G (recency window)
        + get_episodic() : List[Tuple[str,str]]            ' Layer-E (episodic, on-topic)
        - k_default : int
        - soft_fading : bool
        - conflict_policy : str    ' ❖ FILES > newer > older (dedup)
    }

    class ConversationLog {
        + append_turn(user_text:str, assistant_text:str, source:str="chat") : None
        + tail_pairs(k:int=5) : List[Tuple[str,str]]
        - path : Path            ' PATHS.logs/conversation.jsonl
        - fsync : bool
    }

    class HistoryEmbeddingWorker {
        + enqueue_tail() : None
        + process() : None
        + publish() : None          ' os.replace(dynamic → stable)
        - staging_path : Path
        - stable_path  : Path
        - last_offset  : int
        - overlap_chunks : int
    }

    class ConvMemStore {
        + load() : List[Tuple[str,str,Dict]]
        + save(items:List[Tuple[str,str,Dict]]) : None
        + append(item:Tuple[str,str,Dict]) : None
        + evict(ids:List[str]) : None
        - path : Path            ' e.g. PATHS.logs/convmem_e.json
        - backend : str          ' "json" | "sqlite"
    }

    ' Ingestion flow wiring (real)
    DocumentLoader --> Chunker : raw text
    Chunker --> Embedder : chunks

    IngestionManager --> DocumentLoader
    IngestionManager --> Chunker
    IngestionManager --> Embedder
    IngestionManager --> ChromaVectorStoreBase
    IngestionManager --> FileManifest
    Paths .> FileManifest

    ' History persistence and selection-only index
    ConversationMemory --> ConversationLog : reads G tail
    ConversationMemory --> HistoryStoreChroma  : reads E snapshot
    HistoryEmbeddingWorker --> ConversationLog  : read new tail
    HistoryEmbeddingWorker --> HistoryStoreChroma : write/publish
    ConversationMemory --> ConvMemStore : uses (metadata; capacity/fading)

    ' Config wiring for storage paths
    Paths .> ChromaVectorStoreBase : uses PATHS.chroma_db
    Paths .> ConversationLog : uses PATHS.logs
}

'──────────────────────────────────────────────────────────────
'  2) RETRIEVAL & RANKING
'──────────────────────────────────────────────────────────────
package "Retrieval & Ranking" {

    class DocScore {
        + id : str
        + score : float
    }

    class Reranker {
        + rerank(ids:List[str], query:str) : List[str]
    }

    class Retriever {
        + retrieve(query:str, k:int=10) : List[DocScore]
        - _vs : ChromaVectorStoreBase
        - _emb : Embedder
        - _reranker : Reranker
    }

    Retriever --> ChromaVectorStoreBase
    Retriever --> Embedder
    Retriever --> Reranker
    Retriever .> DocScore
}

'──────────────────────────────────────────────────────────────
'  3) AGENTS (A0–A5)
'──────────────────────────────────────────────────────────────
package "Agents (app/agents)" {

    class A0_FileScopeSelector {
        + filter(manifest:List[Dict], toggles:Dict, lock:bool) : Dict
        - alias_map : Dict[str,str]
        - reason_trace : List[str]
    }

    class A1_DCI {
        + build_files_block(named_files:List[str], lock:bool) : str
        - pack_threshold_tokens : int
        - file_manifest : Optional[Any]
    }

    class A2_PromptShaper {
        + propose(question:str) : Dict[str,str]                ' {intent, domain, headers}
        + audit_and_rerun(shape:Dict, s_ctx:List[str]) : bool  ' single bounded re-run gate
    }

    class A3_NLIGate {
        + filter(candidates:List[str], question:str) : List[str]
        - theta : float
    }

    class A4_Condenser {
        + condense(kept:List[str]) : List[str]   ' S_ctx lines: Facts/Constraints/Open Issues
    }

    class A5_SchemaEnforcer {
        + validate(artifact:str, spec:str) : Dict
        - max_repairs : int
        - last_result : Dict
    }
}

'──────────────────────────────────────────────────────────────
'  5) PROMPT ORCHESTRATION
'──────────────────────────────────────────────────────────────
package "Prompt Orchestration" {

    class PromptBuilder {
        + build(question:str, files_block:str, s_ctx:List[str], shape:Dict=None) : str
        - template : str
    }

    class LLMClient {
        + complete(prompt:str) : str
        + estimate_cost(tokens:int) : float
        - model : str
    }

    class JSONEnvelope {
        + agent : str
        + goal : str
        + timestamp : str
        + request_id : str
        + turn_id : int
        + source : str
        + version : str
        + escalate : bool
        + reason : str
        + provenance : Dict
        + payload : Dict
    }
}

'──────────────────────────────────────────────────────────────
'  6) APPLICATION LAYER (Controller & UI)
'──────────────────────────────────────────────────────────────
package "Application Layer" {

    class AppController {
        + handle(user_prompt:str, named_files:List[str], exact_lock:bool) : str
        - shaper : A2_PromptShaper
        - dci : A1_DCI
        - gate : A3_NLIGate
        - condenser : A4_Condenser
        - retriever : Retriever
        - reranker : Reranker
        - prompt_builder : PromptBuilder
        - llm : LLMClient
        - eligibility_pool : Set[str]
        - exact_lock : bool
        - convmem : ConversationMemory
        - debug_logger : DebugLogger
        - file_scope : A0_FileScopeSelector
        - schema_enforcer : A5_SchemaEnforcer
    }

    class StreamlitUI {
        + render() : None
        + external_reply_box() : str                          ' UI-08
        + send_to_history(text:str) : None                    ' UI-09
        + persist_history_toggle(on:bool) : None              ' UI-11
        + clear_history() : None                              ' UI-12
        + set_history_controls(k:int, e_budget:int, synonyms:List[str], mark_important:bool) : None  ' UI-06 / CH-03.7/CH-05
        + export_with_citations() : Path                      ' UI-07
        - ctrl : AppController
    }

    StreamlitUI --> AppController : user actions
}

'──────────────────────────────────────────────────────────────
'  7) CROSS-PACKAGE DEPENDENCIES & FLOW
'──────────────────────────────────────────────────────────────
' Controller Orchestration
AppController --> A2_PromptShaper : propose()
AppController --> A0_FileScopeSelector : filter()
AppController --> A1_DCI          : build_files_block()
AppController --> Retriever       : retrieve() [if not exact_lock]
AppController --> Reranker        : rerank()
AppController --> A3_NLIGate      : filter()
AppController --> A4_Condenser    : condense() -> S_ctx
AppController --> A2_PromptShaper : audit_and_rerun()  ' single bounded re-run gate
AppController --> A5_SchemaEnforcer : validate()
AppController --> PromptBuilder   : build()
AppController --> LLMClient       : complete()

' History exposure (read-only)
AppController .> ConversationMemory : reads G/E (non-authoritative)
PromptBuilder .> ConversationMemory : may show RECENT HISTORY

' External reply import (UI-08/09)
StreamlitUI --> AppController : send_to_history()
AppController --> ConversationLog : append_turn(source="external")

' Ingestion path (updated)
IngestionManager --> DocumentLoader
IngestionManager --> Chunker
IngestionManager --> Embedder
IngestionManager --> ChromaVectorStoreBase
IngestionManager --> FileManifest

' PromptBuilder inputs
PromptBuilder .> A1_DCI        : receives ❖ FILES
PromptBuilder .> A4_Condenser  : receives S_ctx

' Debug logging
AppController --> DebugLogger : logWriteText()/logWriteVar()
StreamlitUI --> DebugLogger   : logWriteText()

' Misc
Settings .> LLMClient : API keys/config
Settings .> Embedder  : API keys/config
SimpleLogger .> AppController : errors only
Paths .> AppController : PATHS used across

note right of AppController
  Authority order in PromptBuilder:
  [Hard Rules] → [Project Memory] → [❖ FILES]
  → [S_ctx] → [Task/Mode]
  (RECENT HISTORY is optional & non-authoritative)
  Personal use only: no MVP; no Tooling package.
end note

note bottom of ChromaVectorStoreBase
  Default now: Chroma-backed persistent store
  (on-disk under PATHS.chroma_db) with
  upsert/query/snapshot and metadata filters.
end note

note bottom of HistoryStoreChroma
  Layer-E selection-only index
  persisted as a Chroma collection
  (e.g., collection "history").
end note

' --- layout anchors (hidden, cosmetic only) ---
DocumentLoader -[hidden]-> Retriever
Retriever -[hidden]-> A0_FileScopeSelector
A5_SchemaEnforcer -[hidden]-> PromptBuilder
PromptBuilder -[hidden]-> StreamlitUI

A0_FileScopeSelector -[hidden]down-> A1_DCI
A1_DCI -[hidden]down-> A2_PromptShaper
A2_PromptShaper -[hidden]down-> A3_NLIGate
A3_NLIGate -[hidden]down-> A4_Condenser
A4_Condenser -[hidden]down-> A5_SchemaEnforcer

Settings -[hidden]down-> SimpleLogger
Paths -[hidden]down-> Settings

ConversationMemory-[hidden]down->  DocumentLoader
LLMClient -[hidden]down-> JSONEnvelope
@enduml
